'use strict'; function e (e) { chrome.storage.sync.get(['wishlist'], ({ wishlist: t }) => { t && t.items ? e(t) : e({ items: [], lastUpdated: null, sortBy: 'title', sortOrder: 'asc' }) }) } async function t (e) { try { const t = await fetch(e); const r = (function (e) { const t = document.createElement('template'); return e = e.trim(), t.innerHTML = e, t.content.cloneNode(!0) }(await t.text())); const n = r.querySelector("span[data-qa='mfeCtaMain#offer0#finalPrice']"); const s = r.querySelector("span[data-qa='mfeCtaMain#offer0#originalPrice']"); const a = r.querySelector("span[data-qa='mfeCtaMain#offer0#discountDescriptor']"); const o = r.querySelector('h1'); try { return { title: o.innerText.trim(), price: n.innerText, ogPrice: s ? s.innerText : null, saleEnds: a ? a.innerText : null, url: e } } catch (t) { throw new Error(`Could not parse response from ${e}`) } } catch (e) { throw e } }chrome.alarms.create('wishlistPoll', { periodInMinutes: 60 }), chrome.alarms.onAlarm.addListener(function () { return new Promise(r => { e(n => { if (!n.items.length) return r(); const s = n.items.map(e => t(e.url)); Promise.allSettled(s).then(t => { const s = n.items.map(e => { const r = t.find(t => t.status === 'fulfilled' && t.value.url === e.url); return r ? r.value : Object.assign(Object.assign({}, e), { outdated: !0 }) }); const a = { items: s, lastUpdated: Date.now() }; !(function (e) { const t = e.reduce((e, t) => t.ogPrice ? e + 1 : e, 0); chrome.action.setBadgeText({ text: t ? `${t}` : '' }), chrome.action.setBadgeBackgroundColor({ color: '#00439c' }) }(s)), (async function (t, r = !1) { return await new Promise(n => { r ? e(e => { chrome.storage.sync.set({ wishlist: Object.assign(Object.assign({}, e), t) }, () => { n() }) }) : chrome.storage.sync.set({ wishlist: t }, () => { n() }) }) }(a, !0)).then(r) }).catch(e => { console.log('Data refresh error: ', e), r() }) }) }) })
